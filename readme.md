
# 기사의 여행
    
해밀턴 경로와 기사의 여행

1. 서론
  1.1 문제 소개
기사의 여행(Knight’s Tour)이라고 불리는 문제는 체스게임의 말 중 하나인 기사가 정해진 이동 규칙을 따라 움직일 때 체스판의 모든 위치를 정확히 한 번씩 방문할 수 있도록 하는 방법을 찾는 문제이다. 
      
그림 1. 체스 말 Knight의 이동 규칙


Knight는 이동할 때 두 칸 전진 후 오른쪽이나 왼쪽 칸으로 이동할 수 있다. 따라서 장애물이 없다면 Knight는 위의 그림과 같이 n번째 위치에서 n+1번째인 최대 8개의 다음 위치로 이동할 수 있다. 이 문제를 직접 풀어보면 시간도 많이 소요되고 쉽지도 않다는 것을 느낄 수 있다. 이 문제를 해밀턴 경로 문제로 바꿔서 접근하는 방법을 소개하도록 하겠다.

2. 본론 
  2.1. 해밀턴 경로
그래프에서 해밀턴 경로는 그래프의 모든 꼭짓점을 포함하는 경로이다.

그림 2. 노드가 6개인 그래프
      
그림 3. 그래프의 해밀턴 경로


그림 2의 그래프는 6개의 노드와 10개의 간선으로 이루어져 있다. 이 그래프의 한 노드를 시작점으로 하여 중복 없이 모든 노드를 방문할 수 있는 경로를 해밀턴 경로라고 부른다. 또, 해밀턴 경로를 갖는 그래프는 자취 존재 그래프(traceable graph)라고 하는데 어떤 그래프가 자취 존재 그래프인지 여부를 묻는 결정 문제는 해밀턴 경로 문제라고 한다. 해밀턴 경로 문제는 한 붓 그리기로 유명한 오일러 회로 문제와 유사하지만 한 qs 방문한 노드는 다시 방문하지 못한다는 점에서 범위가 더 좁다. 오일러 회로임을 증명하는 문제는 간단하지만, 의외로 해밀턴 경로 문제 그 자체는 NP 문제이다. 문제에 해밀턴 경로가 존재한다는 것이 전제되어 있으므로 자취 존재 그래프임을 증명하는 과정은 생략하겠다.

  2.2. 해밀턴 경로 적용
기사의 여행 문제에 해밀턴 경로를 적용하기 위해서는 체스판 위에서의 기사의 행동반경을 그래프로 변환해야 한다. 먼저 체스판 위에 이동할 수 있는 모든 지점을 노드로 두고, 한 지점에서 기사가 이동 가능한 지점을 간선으로 이은 그래프로 변환할 수 있다.

그림 4. Knight의 이동 경로 그래프


Knight의 이동 경로를 그래프로 변환하면 위와 같은 자취 존재 그래프를 얻을 수 있다. 여기서 해밀턴 경로를 찾는다면 기사의 여행 문제의 해를 구할 수 있다. 이 문제에서의 해밀턴 회로 즉, 해밀턴 경로 중에서도 마지막 노드가 출발 노드와 이어진 경우는 당연히 해밀턴 경로의 개수보다 훨씬 작다. 알려진 바에 따르면 기사의 여행 문제에서 해밀턴 회로의 경우의 수는 이미 26조 개 이상이라고 밝혀냈지만, 해밀턴 경로 경우의 수는 너무 많아서 그 수조차 파악하지 못하고 있다. 한 마디로 경우의 수가 너무 많기 때문에 일반적인 해법을 구할 수 없는 문제라는 뜻이다.

  2.3. 풀이 방법
 이 문제를 푸는 일반적인 해는 없지만 높은 확률로 해를 구할 수 있는 알고리즘이 존재한다. 바로 Warnsdorff 알고리즘이라는 휴리스틱(heuristic) 방법인데, Knight가 이동할 다음 지점을 찾는 데에 아주 간단한 방법이다. Warnsdorff's Rule은 다음 방문 가능한 지점 중에서 이미 방문한 지점을 제외한 degree가 가장 적은 곳, 즉 이동할 지점에서 방문할 곳이 별로 없는 곳을 기준으로 이동을 하면 해를 구할 가능성이 높아진다. 
 기사가 어느 칸을 도달했다고 하자. 다음으로 갈 수 있는 경로는 최대 8개 이다. 그 지점의 degree를 관찰 후, 가장 작은 지점을 현재 지점에서 갈 곳으로 선택한다. 
프로그램으로 구현할 때에 백트래킹 알고리즘의 heuristic function으로 사용하면 효율적으로 해를 구할 수 있다.

그림  Knight의 경로 선택 상황


예를 들어, Knight가 다음과 같은 경로로 이동했다고 가정하자. 초록색 지점이 출발 지점이고 파란 간선이 현재까지의 이동 경로이며, 파란색 지점이 현재 지점이다. 현재 지점에서 고려할 수 있는 이동 지점은 보라색 X표 지점들이다. 이 중 1시 방향 X표 지점부터 시계방향으로 degree를 고려하면 1번(이미 방문), 2번(degree = 4), 3번(degree = 5), 4번(degree = 5), 5번(degree = 4), 6번(이미 방문), 7번(degree = 2), 8번(degree = 2)이다. 여기서 degree가 가장 적은 7번이나 8번 지점을 다음 방문 지점으로 선택하게 된다. 이 방법으로 구한 최종 해는 다음과 같다.

그림  기사의 여행 문제 해

3. 결론
해밀턴 경로를 이용하여 기사의 여행 문제를 풀었다. 무작정 체스판 위에서 문제를 푸는 것보다 그래프로 문제를 변환하여 푸는 것이 더 가시적일 뿐만 아니라 이를 코드로 구현할 때도 훨씬 수월하다. 이 문제를 코드로 해를 구하는 가장 일반적인 방법은 백트래킹으로 구현하는 것인데 원리를 알고 접근하는 것과 무작정 부루트포스로 구현한 코드의 실행시간은 차이가 확연히 난다. 네이게이션, 택배 운송 경로 시스템, 드론 경로 설정 시스템 등 프로그래머들은 현실 세계에서 최적의 해밀턴 경로를 빠르게 구하는 코드를 구현할 수 있어야 한다. 현실 세계를 적절히 그래프로 변환하여 접근하는 기술과 수학적 원리를 가지고 코드를 짜는 것이 프로그래머에게 매우 중요한 소양이다.
